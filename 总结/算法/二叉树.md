#  äºŒå‰æ ‘

**äºŒå‰æ ‘ï¼š**æ˜¯æ ‘çš„ä¸€ç§ç‰¹æ®Šç»“æ„ï¼Œåœ¨äºŒå‰æ ‘ä¸­æ¯ä¸ªèŠ‚ç‚¹æœ€å¤šåªèƒ½æœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹ã€‚

**äºŒå‰æ ‘çš„æ·±åº¦ä¼˜å…ˆéå†ï¼ˆDFSï¼‰ä¸å¹¿åº¦ä¼˜å…ˆéå†ï¼ˆBFSï¼‰**

**æ·±åº¦ä¼˜å…ˆéå†ï¼š**ä»æ ¹èŠ‚ç‚¹å‡ºå‘ï¼Œæ²¿ç€å·¦å­æ ‘æ–¹å‘è¿›è¡Œçºµå‘éå†ï¼Œç›´åˆ°æ‰¾åˆ°å¶å­èŠ‚ç‚¹ä¸ºæ­¢ã€‚ç„¶åå›æº¯åˆ°å‰ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè¿›è¡Œå³å­æ ‘èŠ‚ç‚¹çš„éå†ï¼Œç›´åˆ°éå†å®Œæ‰€æœ‰å¯è¾¾èŠ‚ç‚¹ä¸ºæ­¢ã€‚

**å¹¿åº¦ä¼˜å…ˆéå†**ï¼šä»æ ¹èŠ‚ç‚¹å‡ºå‘ï¼Œåœ¨æ¨ªå‘éå†äºŒå‰æ ‘å±‚æ®µèŠ‚ç‚¹çš„åŸºç¡€ä¸Šçºµå‘éå†äºŒå‰æ ‘çš„å±‚æ¬¡ã€‚

## äºŒå‰æ ‘çš„éå†æ–¹å¼



äºŒå‰æ ‘çš„éå†é€šå¸¸ä½ä»¥ä¸‹ä¸¤ç§æƒ…å†µï¼š**æ·±åº¦ä¼˜å…ˆæœç´¢å’Œå®½åº¦ä¼˜å…ˆæœç´¢**ï¼Œå…¶ä¸­æ·±åº¦ä¼˜å…ˆæœç´¢å¯ä»¥åˆ†ä¸ºï¼šå‰åºéå†ã€ä¸­åºéå†å’Œåç»­éå†ã€‚

![image-20200402150043414](äºŒå‰æ ‘çš„éå†.assets/image-20200402150043414.png)

**å‰åºéå†ï¼š**å…ˆè®¿é—®æ ¹èŠ‚ç‚¹ï¼Œåœ¨è®¿é—®å·¦å­èŠ‚ç‚¹ï¼Œæœ€åè®¿é—®å³å­èŠ‚ç‚¹ã€‚å¦‚ä¸Šå›¾æ‰€ç¤ºçš„äºŒå‰æ ‘æŒ‰ç…§å‰åºéå†çš„é¡ºåºä¸ºï¼š10ã€6ã€4ã€8ã€14ã€12ã€16ã€‚

**ä¸­åºéå†ï¼š**å…ˆè®¿é—®å·¦å­èŠ‚ç‚¹ï¼Œåœ¨è®¿é—®æ ¹èŠ‚ç‚¹ï¼Œæœ€åè®¿é—®å³å­èŠ‚ç‚¹ã€‚å¦‚ä¸Šå›¾æ‰€ç¤ºçš„äºŒå‰æ ‘æŒ‰ç…§å‰åºéå†çš„é¡ºåºä¸ºï¼š4ï¼Œ6ï¼Œ8ï¼Œ10ï¼Œ12ï¼Œ14ï¼Œ16ã€‚

**åç»­éå†ï¼š**å…ˆè®¿é—®å·¦å­èŠ‚ç‚¹ï¼Œåœ¨è®¿é—®å³å­èŠ‚ç‚¹ï¼Œæœ€åè®¿é—®æ ¹èŠ‚ç‚¹ã€‚å¦‚ä¸Šå›¾æ‰€ç¤ºçš„äºŒå‰æ ‘æŒ‰ç…§ååºéå†çš„é¡ºåºä¸ºï¼š4ã€8ã€6ã€12ã€16ã€14ã€10ã€‚

**å®½åº¦ä¼˜å…ˆæœç´¢ï¼š**å…ˆè®¿é—®æ ‘çš„ç¬¬ä¸€å±‚èŠ‚ç‚¹ï¼Œå†è®¿é—®æ ‘çš„ç¬¬äºŒå±‚èŠ‚
ç‚¹â€¦â€¦ä¸€ç›´åˆ°è®¿é—®åˆ°æœ€ä¸‹é¢ä¸€å±‚èŠ‚ç‚¹ã€‚åœ¨åŒä¸€å±‚èŠ‚ç‚¹ä¸­ï¼Œä»¥ä»å·¦åˆ°
å³çš„é¡ºåºä¾æ¬¡è®¿é—®ã€‚å¦‚ä¸Šå›¾æ‰€ç¤ºçš„äºŒå‰æ ‘æŒ‰ç…§å®½åº¦ä¼˜å…ˆæœç´¢çš„é¡ºåºä¸ºï¼š10ã€6ã€14ã€4ã€8ã€12ã€16ã€‚

## äºŒå‰æ ‘çš„å¸¸è§ç‰¹ä¾‹

### äºŒå‰æœç´¢æ ‘

äºŒå‰æœç´¢æ ‘ï¼ˆBinary Search Treeï¼‰ï¼Œä¹Ÿåˆ«ç§°ä¸ºäºŒå‰æŸ¥æ‰¾æ ‘ï¼ŒäºŒå‰æ’åºæ ‘ã€‚**äºŒå‰æœç´¢æ ‘ä¸­ ï¼Œ å·¦å­èŠ‚ç‚¹æ€»æ˜¯å°äºæˆ–ç­‰äºæ ¹èŠ‚ç‚¹ ï¼Œè€Œå³å­èŠ‚ç‚¹æ€»æ˜¯å¤§äºæˆ–ç­‰äºæ ¹èŠ‚ç‚¹ ã€‚**  ä¹Ÿå°±æ˜¯ï¼Œæ ¹èŠ‚ç‚¹çš„å€¼å¤§äºå…¶å·¦å­æ ‘ä¸­ä»»æ„ä¸€ä¸ªèŠ‚ç‚¹çš„å€¼ï¼Œå°äºå…¶å³èŠ‚ç‚¹ä¸­ä»»æ„ä¸€èŠ‚ç‚¹çš„å€¼ï¼Œè¿™ä¸€è§„åˆ™é€‚ç”¨äºäºŒå‰æŸ¥æ‰¾æ ‘ä¸­çš„æ¯ä¸€ä¸ªèŠ‚ç‚¹ã€‚å¦‚ä¸‹å›¾æ‰€ç¤ºã€‚

<img src="äºŒå‰æ ‘çš„éå†.assets/image-20200406155647529.png" alt="image-20200406155647529" style="zoom:80%;" />

#### **ç‰¹ç‚¹å¦‚ä¸‹ï¼š**

- æ ¹èŠ‚ç‚¹å€¼å¤§äºæˆ–ç­‰äºå…¶å·¦å­æ ‘ä»»æ„èŠ‚ç‚¹çš„å€¼ã€‚
- æ ¹èŠ‚ç‚¹å€¼å°äºæˆ–ç­‰äºå³å­æ ‘ä»»æ„èŠ‚ç‚¹çš„å€¼
- ä»¥ä¸Šä¸¤ä¸ªæ€§è´¨åœ¨äºŒå‰æœç´¢æ ‘ä¸­çš„**æ¯ä¸€ä¸ªèŠ‚ç‚¹å‡æ»¡è¶³**
- äºŒå‰æœç´¢æ ‘çš„ä¸­åºéå†ä¸º**å‡åºåºåˆ—**ã€‚

#### æ„å»ºäºŒå‰æœç´¢æ ‘

```cpp
#include <iostream>
using namespace std;
struct TreeNode
{
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
}; 
void buildBST(TreeNode *&root, int x)   //è¿™é‡Œæ˜¯èŠ‚ç‚¹æŒ‡é’ˆçš„å¼•ç”¨
{
    if (root == NULL) 
    {
        root = new TreeNode(x);
        return;
    }
    //å»é‡
    // if (x == root->val)
    // {
    //     return;
    // }
    if (x < root->val)
    {
        buildBST(root->left, x);
    }
    if(x>=root->val)
    {
        buildBST(root->right, x);
    }
}

void inOrder(TreeNode *root)
{
    if (root == NULL)
    {
        return;
    }
    inOrder(root->left);
    cout << root->val << " ";
    inOrder(root->right);
}
int main()
{
    int x;
    TreeNode *root = NULL;
    while (cin >> x)
    {
        buildBST(root, x);
    }
    inOrder(root);
    cout << endl;
    return 0;
}
```





### å †

### çº¢é»‘æ ‘

## äºŒå‰æ ‘çš„éå†

å¯¹äºäºŒå‰æ ‘çš„ä¸‰ç§éå†æ–¹å¼éƒ½æœ‰é€’å½’å’Œå¾ªç¯ä¸¤ç§å®ç°æ–¹æ³•ã€‚

### [å‰åºéå†](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/)

**é€’å½’æ–¹æ³•**

```cpp
struct TreeNode
{
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x):val(x),left(NULL),right(NULL){}
};
//é€’å½’æ–¹æ³•
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        if(root==NULL)
        {
            return res;
        }
        res.push_back(root->val);
        preorderTraversal(root->left);
        preorderTraversal(root->right);
        return res;

    }
private:
    vector<int> res;
};
```

**è¿­ä»£æ–¹æ³•**ï¼Œé€’å½’çš„æœ¬è´¨å°±æ˜¯æ ˆç»“æ„ï¼Œè¿­ä»£çš„æ–¹æ³•å°±æ˜¯æ„å»ºä¸€ä¸ªæ ˆæ¥ä»£æ›¿ç³»ç»Ÿæ ˆã€‚

```cpp
struct TreeNode
{
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x):val(x),left(NULL),right(NULL){}
};
class Solution {
public:
  vector<int> preorderTraversal(TreeNode *root)
    {
      	//æ„å»ºä¸€ä¸ªæ ˆ
        stack<TreeNode *> s;
        vector<int> res;
        if (root == NULL)
        {
            return res;
        }
      s.push(root);
      while(!s.empty())
      {
          TreeNode*temp = s.top();
          res.push_back(temp->val);
          s.pop();
          //åéå†å³å­æ ‘ï¼Œæ‰€ä»¥æ ¹æ®æ ˆçš„ç‰¹æ€§å…ˆå‹å…¥å³å­æ ‘
          if(temp->right)
          {
              s.push(temp->right);
          }
          if(temp->left)
          {
              s.push(temp->left);
          }
          temp  = NULL;  //é‡Šæ”¾æŒ‡é’ˆ
      }
      return res;
    }
};
```

<img src="äºŒå‰æ ‘çš„éå†.assets/image-20200406111944496.png" alt="image-20200406111944496" style="zoom: 80%;" />

ä¸ºäº†å’Œåç»­çš„éå†æ–¹æ³•ç»Ÿä¸€æ¶æ„ï¼Œè¿™é‡Œæä¾›å¦ä¸€ç§è¿­ä»£æ–¹æ³•

```cpp
class Solution
{
public:
    vector<int> preorderTraversal(TreeNode *root)
    {
        stack<TreeNode *> s;
        vector<int> res;
        TreeNode *temp = root;
        while (   || !s.empty())
        {
            while (temp)
            {
                s.push(temp->right);    // å°±ç®—æ˜¯ç©ºå¯è¦å‹å…¥æ ˆä¸­ã€‚
                res.push_back(temp->val);
                temp = temp->left;
            }
            temp = s.top();
            s.pop();
        }
        return res;
    }
};
```



### [ä¸­åºéå†](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/er-cha-shu-de-zhong-xu-bian-li-by-leetcode/)

**é€’å½’æ–¹æ³•**

```cpp
struct TreeNode
{
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x):val(x),left(NULL),right(NULL){}
};
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        if(root==NULL)
        {
            return res;
        }
        inorderTraversal(root->left);
        res.push_back(root->val);
        inorderTraversal(root->right);
        return res;
    }
private:
    vector<int> res;
};
```

**è¿­ä»£æ–¹æ³•**

æ¯åˆ°ä¸€ä¸ªèŠ‚ç‚¹ Aï¼Œå› ä¸ºæ ¹çš„è®¿é—®åœ¨ä¸­é—´ï¼Œå°† A å…¥æ ˆã€‚ç„¶åéå†å·¦å­æ ‘ï¼Œæ¥ç€è®¿é—® Aï¼Œæœ€åéå†å³å­æ ‘ã€‚åœ¨è®¿é—®å®Œ A åï¼ŒA å°±å¯ä»¥å‡ºæ ˆäº†ã€‚å› ä¸º A å’Œå…¶å·¦å­æ ‘éƒ½å·²ç»è®¿é—®å®Œæˆã€‚

```cpp
struct TreeNode
{
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x):val(x),left(NULL),right(NULL){}
};
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*> s;
        TreeNode*temp =root;
        if(root==NULL)
        {
            return res;
        }
        while(temp||!s.empty())
        {
            //éå†å·¦å­æ ‘
            while(temp)
            {
                s.push(temp);
                temp = temp->left;
            }
            temp = s.top();
            s.pop();
            res.push_back(temp->val);
            temp = temp->right;    //æŸ¥çœ‹å³å­èŠ‚ç‚¹
        }
        return res;
    }
};

```

### [åç»­éå†](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/solution/er-cha-shu-de-hou-xu-bian-li-by-leetcode/)

**é€’å½’æ–¹æ³•**

```cpp
struct TreeNode
{
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x):val(x),left(NULL),right(NULL){}
};
//é€’å½’æ–¹æ³•
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {      
        if(root==NULL)
        {
            return res;
        }
        postorderTraversal(root->left);
        postorderTraversal(root->right);
        res.push_back(root->val);
        return res; 
    }
private:
    vector<int> res;
};

```

**è¿­ä»£æ–¹æ³•1**

è¿™é‡Œé‡‡ç”¨äº†é‡‡ç”¨äº†ç±»ä¼¼å‰åºéå†çš„æ–¹æ³•ï¼ˆå°†å‰åºéå†çš„root->left->rightæ”¹ä¸ºroot->right->leftï¼‰ï¼Œå†å°†æœ€åç»“æœé€†åºã€‚

```cpp
struct TreeNode
{
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x):val(x),left(NULL),right(NULL){}
};
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*> s;
        if(root==NULL)
        {
            return res;
        }
        s.push(root);
        while(!s.empty())
        {
            TreeNode*temp = s.top();
            res.push_back(temp->val);
            s.pop();
            //è¿™é‡Œéœ€è¦å…ˆè®¿é—®å³èŠ‚ç‚¹ï¼Œæ•…è€Œå…ˆå°†åšå·¦å­èŠ‚ç‚¹å‹å…¥æ ˆä¸­ 
            if(temp->left)
            {
                s.push(temp->left);
            }
            if(temp->right)
            {
                s.push(temp->right);
            }
            temp==NULL;
        }
        reverse(res.begin(),res.end());
        return res; 
    }
};
```

**æ ‡å‡†åç»­éå†çš„è¿­ä»£æ–¹æ³•**ï¼Œæ ‡å‡†çš„è¿­ä»£æ–¹æ³•æ¯”è¾ƒå›°éš¾ï¼Œç”±äºæ ¹èŠ‚ç‚¹éœ€è¦å†æœ€åè®¿é—®ï¼Œæ‰€ä»¥é€šè¿‡æ ¹èŠ‚ç‚¹è®¿é—®å·¦å­èŠ‚ç‚¹åï¼Œpopåå›åˆ°æ ¹èŠ‚ç‚¹æ—¶å¹¶ä¸èƒ½å¯¹æ ¹èŠ‚ç‚¹è¿›è¡Œpopå’Œæ·»åŠ æ“ä½œã€‚

```cpp
struct TreeNode
{
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x):val(x),left(NULL),right(NULL){}
};

class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> res;
        if(root==NULL)
        {
            return res;
        }
        stack<TreeNode*>s;
        TreeNode*cur = root;
        TreeNode*pre = NULL;   //è®°å½•å‰ä¸€èŠ‚ç‚¹
        while(cur||!s.empty())
        {
            while(cur)
            {
                s.push(cur);
                cur = cur->left;
            }
            cur = s.top();
            //å½“å‰å·¦å­èŠ‚ç‚¹ä¸ºç©ºï¼Œå¦‚æœå³å­èŠ‚ç‚¹ä¹Ÿä¸ºç©ºï¼Œåˆ™æ·»åŠ å½“å‰èŠ‚ç‚¹ã€‚
            //å¦‚æœå½“å‰èŠ‚ç‚¹çš„å³å­èŠ‚ç‚¹è¢«è®°å½•è¿‡ï¼Œåˆ™æ·»åŠ å½“å‰æ ¹èŠ‚ç‚¹
            if(cur->right==NULL||cur->right==pre) 
            {
                res.push_back(cur->val);
                s.pop();
                pre = cur;     //è®°å½•å·²ç»æ·»åŠ çš„èŠ‚ç‚¹
                cur = NULL;    //å¦‚æœå½“å‰èŠ‚ç‚¹å·²è¢«æ·»åŠ ï¼Œåˆ™ç½®ä¸ºç©ºï¼Œä¸å†è¿›è¡ŒæŸ¥æ‰¾
            }
            else
            {
                cur = cur->right;
            }
        }
        return res;
    }
};
//å¦ä¸€ç§æ€è·¯
class Solution
{
public:
    vector<int> postorderTraversal(TreeNode *root)
    {
        vector<int> res;
        if (!root)
            return res;
        stack<TreeNode *> s;
        s.push(root);
        TreeNode *cur;
        while (!s.empty())
        {
            cur = s.top();
            s.pop();
            //æ— å·¦å³å­èŠ‚ç‚¹ï¼Œæ·»åŠ 
            if (!cur->left && !cur->right)
            {
                res.push_back(cur->val);
            }
            else
            {
                //å¯¹äºæœ‰å·¦å³å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ï¼Œå°†å…¶å·¦å³å­èŠ‚ç‚¹ç½®ç©ºã€‚æ–¹ä¾¿åç»­åˆ¤æ–­æ·»åŠ 
                TreeNode *left = cur->left;
                TreeNode *right = cur->right;
                //å½“å‰èŠ‚ç‚¹çš„å·¦å³èŠ‚ç‚¹ç½®ç©º
                cur->left = NULL;
                cur->right = NULL;
                //ç„¶åå°†è¯¥èŠ‚ç‚¹å‹å…¥æ ˆä¸­ï¼Œè¯¥èŠ‚ç‚¹å·²ç»æ²¡æœ‰äº†å·¦å³å­èŠ‚ç‚¹
                //æœ€åè®¿é—®æ ¹èŠ‚ç‚¹ï¼Œæ‰€ä»¥æœ€å…ˆå…¥æ ˆ
                s.push(cur);
                //åè¾¹äº†å³å­èŠ‚ç‚¹ï¼Œå…ˆå…¥æ ˆ
                if (right)
                {
                    s.push(right);
                }
                //æœ€å…ˆè®¿é—®å·¦å­èŠ‚ç‚¹ï¼Œæœ€åå…¥æ ˆ
                if (left)
                {
                    s.push(left);
                }
            }
        }
        return res;
    }
};
```

### å®½åº¦ä¼˜å…ˆæœç´¢

**é€’å½’çš„æ–¹æ³•**

åˆ©ç”¨æ·±åº¦ä¼˜å…ˆæœç´¢ï¼ˆDPSï¼‰çš„æ–¹æ³•è¿›è¡Œéå†ï¼Œé€šè¿‡äºŒç»´æ•°ç»„ï¼Œå°†ç»“æœåˆ†å±‚è¾“å‡ºã€‚è™½ç„¶é€’å½’æŒ‰ç…§å‰åºéå†çš„æ–¹å¼è¿›è¡Œï¼Œä½†æ˜¯é€šè¿‡æ•°æ®è¿›è¡Œåˆ†å±‚è¾“å…¥å®ç°äº†å±‚æ¬¡éå†ã€‚

```cpp
class Solution {
public:
    vector<vector<int>> res;   
    vector<vector<int>> levelOrder(TreeNode* root) 
    {
        addVector(root,0);      //è°ƒç”¨é€’å½’å‡½æ•°
        return res;
    }
  
    void addVector(TreeNode* root,int level)
    {
        if(root == NULL)    return;
        //levelè¡¨ç¤ºå±‚æ•°ï¼Œä¹Ÿå¯¹åº”äºŒç»´æ•°ç»„çš„ç¬¬ä¸€å±‚ç´¢å¼•ï¼Œ
        if(res.size()==level)       
        {
            res.resize(level+1);    
        }
        res[level].push_back(root->val);
        addVector(root->left,level+1);
        addVector(root->right,level+1);
    }
};
```

**è¿­ä»£çš„æ–¹æ³•**

åˆ©ç”¨é˜Ÿåˆ—çš„å…ˆè¿›å…ˆå‡ºçš„ç‰¹æ€§æ¥å®ç°å®½åº¦ä¼˜å…ˆæœç´¢å±‚æ¬¡éå†ã€‚

```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> ans;
        vector<int> res;
        if(root==NULL)
        {
            return ans;
        }
        queue<TreeNode*>q;
        q.push(root);
        while(!q.empty())
        {
            int length = q.size();
            res.clear();
            //å°†å½“å‰å±‚å¤„ç†å®Œåå†æ·»åŠ è¿›ans
            while(length--)
            {
                TreeNode*temp = q.front();
                res.push_back(temp->val);
                q.pop();
                if(temp->left)
                {
                    q.push(temp->left);
                }
                if(temp->right)
                {
                    q.push(temp->right);
                }
            }
            ans.push_back(res);
            
        }
        return ans;
    }
};
```

è¿‡ç¨‹å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š

<img src="äºŒå‰æ ‘çš„éå†.assets/image-20200403123950547.png" alt="image-20200403123950547" style="zoom:80%;" />

## äºŒå‰æ ‘åˆ·é¢˜

###  é€’å½’

#### [æ ‘çš„é«˜åº¦](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/submissions/)

<img src="äºŒå‰æ ‘çš„éå†.assets/image-20200403172238131.png" alt="image-20200403172238131" style="zoom: 80%;" />

**é€’å½’çš„æ–¹æ³•**

```cpp
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(root==NULL)	
        {
            return 0;
        }
        int left = maxDepth(root->left);
        int right = maxDepth(root->right);
        return max(left,right)+1;
    }
};
```

**è¿­ä»£æ³•**

è¿™é‡Œä½¿ç”¨çš„æ˜¯å®½åº¦ä¼˜å…ˆæœç´¢çš„æ–¹æ³•æ¥éå†äºŒå‰æ ‘ï¼Œå¹¶ç»Ÿè®¡æ·±åº¦ã€‚

```cpp
struct TreeNode
{
    int val;
    TreeNode*left;
    TreeNode*right;
    //åˆå§‹åŒ–
    TreeNode(int x):val(x),left(NULL),right(NULL){}
};
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(root==NULL)
        {
            return 0;
        }
        queue<TreeNode*>q;
        int depth = 0;
        q.push(root);
        while(!q.empty())
        {
            //è®°å½•å½“å‰é˜Ÿåˆ—ä¸­çš„å…ƒç´ ä¸ªæ•°ï¼Œè¿™é‡Œå³ä¸ºå½“å‰å±‚çš„èŠ‚ç‚¹æ•°
            int level = q.size();
            //åˆ†å±‚æ“ä½œ
            while(level--)
            {
                TreeNode*temp = q.front();
                q.pop();
                if(temp->left) q.push(temp->left);
                if(temp->right) q.push(temp->right);    
            }
            depth++;
        }
        return depth;
    }
};
```

#### [å¹³è¡¡äºŒå‰æ ‘](https://leetcode-cn.com/problems/balanced-binary-tree/description/)

<img src="äºŒå‰æ ‘çš„éå†.assets/image-20200404090608884.png" alt="image-20200404090608884" style="zoom:80%;" />

é€’å½’åˆ¤æ–­å·¦å³å­æ ‘å’Œè‡ªèº«æ˜¯å¦æ»¡è¶³è¦æ±‚å³å¯ã€‚é€’å½’è®¡ç®—æ ‘çš„é«˜åº¦ï¼Œé€’å½’æ¯”è¾ƒå·¦å³å­æ ‘ã€‚

```cpp
class Solution {
public:
    bool isBalanced(TreeNode* root) {
        if(root==NULL) return true;
        //è®¡ç®—å·¦å³å­æ ‘çš„é«˜åº¦
        int left = MaxDepth(root->left);
        int right = MaxDepth(root->right);
        //æ¯”è¾ƒå·¦å³å­æ ‘çš„å·®å€¼
        if(abs(left-right)>1) return false;
        //é€’å½’åˆ¤æ–­å·¦å­æ ‘å’Œå³å­æ ‘æ˜¯å¦æ»¡è¶³å¹³è¡¡äºŒå‰æ ‘çš„æ¡ä»¶
        return abs(left-right)<=1&&isBalanced(root->left)&&isBalanced(root->right);   
    }
private:
    int MaxDepth(TreeNode*node)
    {
        if (node==NULL) return true;
        int left = MaxDepth(node->left);
        int right = MaxDepth(node->right);
        return max(left,right)+1;
    }
};
```

#### [äºŒå‰æ ‘ç›´å¾„]([äºŒå‰æ ‘çš„ç›´å¾„](https://leetcode-cn.com/problems/diameter-of-binary-tree/))

<img src="äºŒå‰æ ‘çš„éå†.assets/image-20200404102943383.png" alt="image-20200404102943383" style="zoom:80%;" />

æœ¬ä½“å¹¶ä¸æ˜¯ç®€å•çš„å·¦å­æ ‘çš„æœ€å¤§é«˜åº¦+å³å­æ ‘çš„æœ€å¤§é«˜åº¦ï¼Œè€Œå®ä¸¤ä¸ªèŠ‚ç‚¹ä½ ä¹‹é—´çš„æœ€å¤§è·¯å¾„é•¿ã€‚ğŸ˜‚ğŸ˜‚

ä¹Ÿå°±æ˜¯å¯¹**æ¯ä¸€ä¸ªèŠ‚ç‚¹**æ±‚å·¦å­æ ‘å’Œå³å­æ ‘æ·±åº¦ä¹‹å’Œï¼Œç„¶åå–å…¶ä¸­æœ€å¤§çš„å€¼ã€‚çœ‹ä¸‹é¢è¿™ä¸ªé¬¼äºŒå‰æ ‘ï¼Œåº”è¯¥æŒ‰ç…§å›¾ç¤ºä¸­çš„è·¯å¾„èµ°æ‰æ˜¯æœ€å¤§è·¯å¾„ã€‚æ‰€ä»¥å†è¿›è¡Œé€’å½’æ—¶è¦ä¸æ–­æ›´æ–°è·¯å¾„å€¼ã€‚

<img src="äºŒå‰æ ‘çš„éå†.assets/image-20200404103531047.png" alt="image-20200404103531047" style="zoom:80%;" />

```cpp
struct TreeNode{
    int val;
    TreeNode*left;
    TreeNode*right;
    TreeeNode(int x):val(x),left(NULL),right(NULL){}
};
class Solution{
public:
    int diameterOfBinaryTree(TreeNode*root)
    {
        if(root==NULL)
            return 0;
        MaxDepth(root);
        return result;
    }
private:
    int result = 0;
    //è®¡ç®—å½“å‰èŠ‚ç‚¹ä¸ºæ ¹èŠ‚ç‚¹æ—¶çš„æœ€å¤§æ·±åº¦
    int MaxDepth(TreeNode*node)
    {
        if(node==NULL)
            return 0;
        int left = MaxDepth(node->left);
        int right = MaxDepth(node->right);
        result = max(result,left+right);
        return max(left,right)+1; //+1 æŒ‡ä»¥root->leftä¸ºæ ¹èŠ‚ç‚¹çš„æœ€å¤§æ·±åº¦+è¯¥èŠ‚ç‚¹åˆ°å½“å‰rootçš„æ·±åº¦1
    }
};
```

#### [äºŒå‰æ ‘ä¸­çš„æœ€å¤§è·¯å¾„å’Œ](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

<img src="äºŒå‰æ ‘.assets/image-20200608105502677.png" alt="image-20200608105502677" style="zoom:80%;" />

ç±»æ¯”[äºŒå‰æ ‘ç›´å¾„]([äºŒå‰æ ‘çš„ç›´å¾„](https://leetcode-cn.com/problems/diameter-of-binary-tree/))ï¼ŒäºŒå‰æ ‘ç›´å¾„æ˜¯å¯¹**æ¯ä¸€ä¸ªèŠ‚ç‚¹**æ±‚å·¦å­æ ‘å’Œå³å­æ ‘æ·±åº¦ä¹‹å’Œï¼Œç„¶åå–å…¶ä¸­æœ€å¤§çš„å€¼ã€‚è€Œæœ¬ä½“æ€æƒ³ç›¸åŒï¼Œå¯¹æ¯ä¸€ä¸ªèŠ‚ç‚¹æ±‚å·¦å³å­æ ‘èŠ‚ç‚¹å’Œçš„æœ€å¤§å€¼ï¼Œå–æœ€å¤§ã€‚ï¼ˆç›¸å½“äºæƒé‡æ­¥æ•°1ï¼Œè€Œæ˜¯å„ä¸ªèŠ‚ç‚¹å€¼ï¼‰

å¯¹äºæ¯ä¸€ä¸ªèŠ‚ç‚¹éƒ½æœ‰ä¸‰ç§æƒ…å†µ

- `root->val+left`
- `root->val+right`
- `root->val`

åœ¨è®¡ç®—`leftå’Œright`æ—¶è¦è€ƒè™‘å·¦å³å­æ ‘è·¯å¾„å’Œæ˜¯å¦å°äº0ï¼Œå¦‚æœå°äº0ï¼Œé‚£å°±ä¸è€ƒè¯•è¯¥å­æ ‘ã€‚

```cpp
class Solution {
    int res = INT_MIN;
public:
    int maxPathSum(TreeNode* root) {
        if(root==NULL) return 0;
        dfs(root);
        return res;
    }
    int dfs(TreeNode*root)
    {
        if(root==NULL) return 0;
        int left = max(dfs(root->left),0);    //å¦‚æœå·¦å­æ ‘ä¹‹å’Œå°äº0ï¼Œé‚£å°±ä¸è€ƒè™‘å·¦å­æ ‘
        int right = max(dfs(root->right),0);  //å¦‚æœå³å­æ ‘ä¹‹å’Œå°äº0ï¼Œé‚£å°±ä¸è€ƒè™‘å³å­æ ‘
        res = max(res,left+right+root->val);
        return max(left,right)+root->val; 
    }
};
```



#### [ç¿»è½¬äºŒå‰æ ‘](https://leetcode-cn.com/problems/invert-binary-tree/submissions/)

<img src="äºŒå‰æ ‘çš„éå†.assets/image-20200404111726126.png" alt="image-20200404111726126" style="zoom:80%;" />

ç”¨é€’å½’çš„æ–¹æ³•å¯ä»¥å¾ˆç®€å•çš„è§£å†³ã€‚

```cpp
struct TreeNode{
    int val;
    TreeNode*left;
    TreeNode*right;
    TreeeNode(int x):val(x),left(NULL),right(NULL){}
};
class Solution {
public:
    //è¿”å›åè½¬åäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹
    TreeNode* invertTree(TreeNode* root) {
        if(root==NULL)
        {
            return NULL;
        }
        TreeNode *temp = root->left;
        root->left = invertTree(root->right);
        root->right = invertTree(temp);
        return root;
    }
};
```

ä¹Ÿå¯ä»¥ä½¿ç”¨è¿­ä»£çš„æ–¹æ³•æ¥å®ç°ï¼Œè¿™é‡Œé‡‡ç”¨å‰åºéå†çš„æ–¹å¼æ¥è¿›è¡Œã€‚

```cpp
class Solution {
public:
    //è¿”å›åè½¬åäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹
    TreeNode* invertTree(TreeNode* root) {
        if(root==NULL)
        {
            return NULL;
        }
        stack<TreeNode*>s;
        s.push(root);
        while(!s.empty())
        {
            TreeNode*cur = s.top();
            s.pop();
            TreeNode*temp = cur->left;
            cur->left = cur->right;
            cur->right = temp;
            if(cur->right) s.push(cur->right);
            if(cur->left) s.push(cur->left);
            cur=NULL;
        	temp=NULL;	
        }
        return root;
    }
};
```



#### [åˆå¹¶è€ŒäºŒå‰æ ‘](https://leetcode-cn.com/problems/merge-two-binary-trees/)

<img src="äºŒå‰æ ‘çš„éå†.assets/image-20200404164407099.png" alt="image-20200404164407099" style="zoom:80%;" />

```cpp
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
        if(t1==NULL) return t2;
        if(t2==NULL) return t1;
        t1->val+=t2->val;
        t1->left = mergeTrees(t1->left,t2->left);
        t1->right = mergeTrees(t1->right,t2->right);
        return t1;
    }
};
```

#### [äºŒå‰æ ‘çš„æ‰€æœ‰è·¯å¾„](https://leetcode-cn.com/problems/binary-tree-paths/)

<img src="äºŒå‰æ ‘.assets/image-20200708100837966.png" alt="image-20200708100837966" style="zoom:80%;" />

```cpp
class Solution {
public:
    vector<string> binaryTreePaths(TreeNode* root) {
        vector<string> res;
        string s;
        dfs(root,res,"");
        return res;

    }
    private:
    void dfs(TreeNode *root, vector<string> &res, string path)
    {
        if(root==NULL) return;
        path += to_string(root->val);
        if(root->left==NULL&& root->right==NULL) 
        {
            res.push_back(path);
        }
        else
        {
            path+="->";
            dfs(root->left,res,path);
            dfs(root->right,res,path);
        }
    }
};
```



#### [è·¯å¾„æ€»å’Œ](https://leetcode-cn.com/problems/path-sum/)

<img src="äºŒå‰æ ‘çš„éå†.assets/image-20200404195507631.png" alt="image-20200404195507631" style="zoom:80%;" />

é¢˜ç›®è¦æ±‚çš„æ˜¯æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„ï¼Œæ‰€ä»¥å†éå†çš„æ—¶å€™ä¸€å®šè¦éå†åˆ°åº•éƒ¨ã€‚

**é€’å½’æ–¹æ³•**

```cpp
class Solution {
public:
    bool hasPathSum(TreeNode* root, int sum) {
        if(root == NULL) return false;
        if(root->left == NULL&&root->right==NULL&&root->val == sum) 
        {
            return true;
        }
        return hasPathSum(root->left,sum-root->val)
            ||hasPathSum(root->right,sum-root->val);
    }
};
```

**è¿­ä»£æ–¹æ³•**ï¼Œç”±äºè®¡ç®—æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„å’Œï¼Œæ‰€ä»¥é‡‡ç”¨åç»­éå†æ›´æ–¹ä¾¿å®æ–½ã€‚

```cpp
class Solution {
public:
    bool hasPathSum(TreeNode* root, int sum) {
        if(root==NULL) return false;
        stack<TreeNode*> s;
        TreeNode*cur = root;
        TreeNode*pre = NULL;  //è®°å½•éå†è¿‡çš„å‰ä¸€èŠ‚ç‚¹
        int curSum = 0;
        while(cur||!s.empty())
        {
            while(cur)
            {
                s.push(cur);
                curSum += cur->val;
                cur=cur->left;
            }
            cur = s.top();
            if(curSum==sum&&cur->right == NULL&&cur->left==NULL)
            {
                return true;
            }
            if(cur->right==NULL||cur->right==pre)
            {
                s.pop();
                curSum -= cur->val;
                pre = cur;
                cur = NULL;
            }
            else
            {
                cur = cur->right;
            }
        }
        return false;
    }
};
```

#### [è·¯å¾„æ€»å’Œ II](https://leetcode-cn.com/problems/path-sum-ii/)

<img src="äºŒå‰æ ‘.assets/image-20200608172654547.png" alt="image-20200608172654547" style="zoom: 67%;" />

```cpp
class Solution {
public:
    vector<vector<int>> pathSum(TreeNode* root, int sum) {
        vector<vector<int>>res;
        vector<int> path;
        dfs(root,sum,path,res);
        return res;
    }
    void dfs(TreeNode*root,int cursum,vector<int>&path,vector<vector<int>>&res)
    {
        if(root==NULL) return;
        path.push_back(root->val);
        if(cursum==root->val&&root->left==NULL&&root->right==NULL)
        {
            res.push_back(path);
        }
        dfs(root->left,cursum-root->val,path,res);
        dfs(root->right,cursum-root->val,path,res);
        //å›æº¯
        path.pop_back();
    }
};
```

#### [ è·¯å¾„æ€»å’Œ III](https://leetcode-cn.com/problems/path-sum-iii/)

<img src="äºŒå‰æ ‘çš„éå†.assets/image-20200405105210814.png" alt="image-20200405105210814" style="zoom:80%;" />

é¢˜ç›®è¦æ±‚çš„è·¯å¾„æ€»åˆå¹¶ä¸é™åˆ¶ä»æ ¹èŠ‚ç‚¹å¼€å§‹ï¼Œåˆ°å¶å­èŠ‚ç‚¹ç»“æŸã€‚æ‰€ä»¥æœ€å®¹æ˜“æƒ³åˆ°çš„æ–¹æ³•å°±æ˜¯è®¡ç®—ä»¥æ¯ä¸€ä¸ªèŠ‚ç‚¹ä¸ºæ ¹èŠ‚ç‚¹æ˜¯çš„è·¯å¾„å’Œï¼Œè®°å½•æ»¡è¶³è¦æ±‚çš„ä¸ªæ•°ã€‚

```cpp
class Solution {
public:
    int pathSum(TreeNode* root, int sum) {
        if(root == NULL) return 0;
        //ä»¥rootæ ¹èŠ‚ç‚¹ä¸ºèµ·ç‚¹çš„æ»¡è¶³æ¡ä»¶çš„è·¯å¾„æ•°
        int res = helper(root,sum);
        if(root->left)
        {
            res +=pathSum(root->left,sum);
        }
        if(root->right)
        {
            res += pathSum(root->right,sum); 
        }
        return res;
    }
private:
    //è¿”å›ä»¥nodeä¸ºæ ¹èŠ‚ç‚¹çš„æ»¡è¶³è·¯å¾„å’Œä¸ºsumçš„è·¯å¾„æ•°
    int helper(TreeNode*node,int sum)
    {
        if(node==NULL) return 0;
        int res = 0;
        if(node->val==sum) res++;
        res += helper(node->left,sum-node->val)+helper(node->right,sum-node->val);
        return res;
    }
    
};
```

å‰ä¸€ç§æ–¹æ³•æœ‰å¤ªå¤šçš„é‡å¤è¿ç®—ï¼Œæ•ˆç‡ä¸å¤Ÿé«˜ã€‚

ä¸‹é¢è¿™ç§æ–¹æ³•é‡‡ç”¨å‰né¡¹å’Œçš„æ–¹æ³•ç»“åˆå“ˆå¸Œè¡¨å­˜å‚¨éå†çš„å‰Nä¸ªèŠ‚ç‚¹çš„å’Œï¼ˆcurSumï¼‰ï¼Œé€šè¿‡å†å“ˆå¸Œè¡¨ä¸­æŸ¥æ‰¾curSum-Sum,æ¥ç¡®å®šæ˜¯å¦å­˜åœ¨æ»¡è¶³æ¡ä»¶çš„è·¯å¾„ã€‚ï¼ˆå‰ç¼€å’Œ+å“ˆå¸Œè¡¨ï¼‰

```
     10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1
ä¾‹å¦‚éå†æœ€äºŒå‰æ ‘æœ€å·¦è¾¹çš„è·¯å¾„ sum = 8
map{{0,1},
	{10,1},
	{15,1},
	{18,1}ï¼Œ   //å½“ç´¯åŠ åˆ°3æ—¶å‘ç°å“ˆå¸Œè¡¨ä¸­å­˜åœ¨18-8ï¼Œæ‰€ä»¥åˆæ»¡è¶³æ¡ä»¶çš„è·¯å¾„ã€‚
	}
```

```cpp
class Solution {
public:
    public:
    int pathSum(TreeNode* root, int sum) {
        if(!root) return 0;
        unordered_map<int, int> mp;
        mp[0] = 1;
        search(root, sum, 0, mp);
        return res;
    }
    int res = 0;
    void search(TreeNode* node, int target, int curSum, unordered_map<int, int>& mp){
        if(!node) return;
        curSum+=node->val;
        if(mp.find(curSum-target)!=mp.end())
            res+=mp[curSum-target];
        mp[curSum]++;
        search(node->left,target,curSum,mp);
        search(node->right,target,curSum,mp);
        mp[curSum]--;
    }
};
```

#### [å¦ä¸€ä¸ªæ ‘çš„å­æ ‘](https://leetcode-cn.com/problems/subtree-of-another-tree/)

<img src="äºŒå‰æ ‘çš„éå†.assets/image-20200405143543958.png" alt="image-20200405143543958" style="zoom:80%;" />

å’Œ [ è·¯å¾„æ€»å’Œ III](https://leetcode-cn.com/problems/path-sum-iii/) ä¸€æ ·ä¹Ÿæ˜¯è¦è¿è¡ŒåŒé€’å½’

sæ˜¯tçš„å­æ ‘å¯ä»¥åˆ†ä¸ºä»¥ä¸‹ä¸‰ç§æƒ…å†µ

- tç­‰äºsæœ¬èº«
- tæ˜¯så·¦å­æ ‘çš„å­æ ‘
- tæ˜¯så³å­æ ‘çš„å­æ ‘

åˆ¤æ–­ä¸¤ä¸ªæ ‘(a,b)ç›¸åŒä¹Ÿå°±æ˜¯åˆ¤æ–­

- açš„æ ¹èŠ‚ç‚¹å’Œbçš„æ ¹èŠ‚ç‚¹å€¼ç›¸åŒ
- açš„å³å­èŠ‚ç‚¹å’Œbçš„å³å­èŠ‚ç‚¹ç›¸åŒ
- açš„å·¦å­èŠ‚ç‚¹å’Œbçš„å·¦å­èŠ‚ç‚¹ç›¸åŒ

```cpp
class Solution {
public:
    bool isSubtree(TreeNode* s, TreeNode* t) {
        if(s==NULL) return false;
        return isEqual(s,t)||isSubtree(s->left,t)||isSubtree(s->right,t);
    }
private:
    bool isEqual(TreeNode* s,TreeNode* t)
    {
        if(s==NULL&&t==NULL) return true;
        if(s==NULL||t==NULL) return false;
        if(s->val!=t->val) return false;
        return isEqual(s->left,t->left)&&isEqual(s->right,t->right);
    }
};
```

#### [å¯¹ç§°äºŒå‰æ ‘](https://leetcode-cn.com/problems/symmetric-tree/)

<img src="äºŒå‰æ ‘çš„éå†.assets/image-20200405151400079.png" alt="image-20200405151400079" style="zoom:80%;" />

åˆ¤æ–­æ˜¯å¦æ˜¯é•œåƒå¯¹ç§°ï¼Œç›¸å½“äºåˆ¤æ–­å·¦å³ä¸¤ä¸ªå­æ ‘æ˜¯å¦â€œç›¸ç­‰â€ï¼Œè¿™é‡Œçš„ç›¸ç­‰å¹¶ä¸æ˜¯å¯¹åº”ç›¸ç­‰ï¼Œè€Œæ˜¯é•œåƒä½ç½®å¯¹åº”ç›¸ç­‰ï¼Œä¹Ÿå°±æ˜¯ï¼ˆå·¦å­æ ‘ç­‰äºå³å­æ ‘ï¼‰

**é€’å½’æ³•**

```cpp
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if(root==NULL) return true;
        return isSymmetricEqual(root->left,root->right);
    }
private:
    bool isSymmetricEqual(TreeNode*t1,TreeNode*t2)
    {
        if(t1==NULL&&t2==NULL) return true;   //é€’å½’ç»ˆæ­¢è¿˜æ²¡å‡ºç°false è‡ªç„¶æ˜¯trueã€‚
        if(t1==NULL||t2==NULL) return false;
        if(t1->val!=t2->val) return false;
        return isSymmetricEqual(t1->right,t2->left)&&isSymmetricEqual(t1->left,t2->right);
    }
};

```

**è¿­ä»£æ³•**

å‚è€ƒä¸­åºéå†çš„è¿­ä»£ç®—æ³•ã€‚

```cpp
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if(!root) return true;
        stack<TreeNode*> left,right;
        auto l = root->left;
        auto r = root->right;
        while(l||r||!left.empty()||!right.empty())
        {
            while(l&&r)
            {
                left.push(l), l=l->left;
                right.push(r),  r = r->right;
            }
            if(l||r) return false;
            l = left.top(),left.pop();
            r = right.top(),right.pop();
            if(l->val!=r->val) return false;
            l = l->right;
            r = r->left;
        }
        return true;
    }
};
```

<img src="äºŒå‰æ ‘çš„éå†.assets/image-20200405152718740.png" alt="image-20200405152718740" style="zoom:50%;" />

#### [ äºŒå‰æ ‘çš„æœ€å°æ·±åº¦](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

<img src="äºŒå‰æ ‘çš„éå†.assets/image-20200405154443953.png" alt="image-20200405154443953" style="zoom:80%;" />

![image-20200405154523183](äºŒå‰æ ‘çš„éå†.assets/image-20200405154523183.png)

æ³¨æ„ä¸Šé¢è¿™ç§æƒ…å†µï¼Œæœ€å°æ·±åº¦ä¸º2.

```cpp
class Solution {
public:
    int minDepth(TreeNode* root) {
        if(root==NULL) return 0;
        int left = minDepth(root->left);
        int right = minDepth(root->right);
        if(left==NULL||right==NULL)    //è€ƒè™‘ç‹¬ç”Ÿå­çš„æƒ…å†µ
        {
            return left+right+1;
        }
        return min(left,right)+1;
    }
};
```

#### [å·¦å¶å­ä¹‹å’Œ](https://leetcode-cn.com/problems/sum-of-left-leaves/)

<img src="äºŒå‰æ ‘çš„éå†.assets/image-20200405164821835.png" alt="image-20200405164821835" style="zoom:80%;" />

éƒ½å…ˆéœ€è¦åˆ¤æ–­æ˜¯å¦ä¸ºå¶å­èŠ‚ç‚¹ï¼Œè¿™ä¸ªå¾ˆé‡è¦ã€‚

```cpp
class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        if(root==NULL) return 0;
        if(isLeaf(root->left))
        {
            /*å¦‚æœå½“å‰èŠ‚ç‚¹çš„å·¦å­æ ‘æ˜¯å¶å­èŠ‚ç‚¹ï¼Œå°±å°†è¯¥å¶å­èŠ‚ç‚¹+å³å­æ ‘ä¸­å¯èƒ½å­˜åœ¨çš„å·¦å¶å­èŠ‚ç‚¹
            ä¾‹å¦‚
                2
               / \
              1   5
             / \
            2   3 
               / \
              1   6
              */    
            return root->left->val+sumOfLeftLeaves(root->right);
        }
        //è¿”å›å·¦å­æ ‘å’Œå³å­æ ‘ä¸­çš„å·¦å¶å­èŠ‚ç‚¹å’Œ
        return sumOfLeftLeaves(root->left)+sumOfLeftLeaves(root->right);
    }
private:
    bool isLeaf(TreeNode* node)
    {
        if(node==NULL) return false;
        return node->left==NULL&&node->right==NULL;
    }
};
```

#### [ æœ€é•¿åŒå€¼è·¯å¾„](https://leetcode-cn.com/problems/longest-univalue-path/)

<img src="äºŒå‰æ ‘çš„éå†.assets/image-20200405180323777.png" alt="image-20200405180323777" style="zoom:80%;" />

æ³¨æ„é¢˜ä¸­è¦æ±‚è·¯å¾„ä¸Šæ¯ä¸€ä¸ªèŠ‚ç‚¹çš„å€¼ç›¸åŒã€‚ï¼ˆç±»æ¯”[äºŒå‰æ ‘çš„ç›´å¾„](https://leetcode-cn.com/problems/diameter-of-binary-tree/))

```cpp
class Solution {
public:
    int longestUnivaluePath(TreeNode* root) {
        if(root==NULL)
            return 0;
        int res = 0;
        getPath(root,res);
        return res;
    }
private:
    int getPath(TreeNode* node,int&res)
    {
        if(node==NULL) return 0;
        int left = getPath(node->left,res);
        int right = getPath(node->right,res);
        int leftPath = (node->left&&node->left->val==node->val)? left+1:0;
        int rightPath = (node->right&&node->right->val==node->val)?right+1:0;
        res = max(res,leftPath+rightPath);
        return max(leftPath,rightPath);
    }
};
```

#### [æ‰“å®¶åŠ«èˆ IIIï¼ˆäºŒå‰æ ‘çš„åŠ¨æ€è§„åˆ’ï¼‰](https://leetcode-cn.com/problems/house-robber-iii/)

<img src="äºŒå‰æ ‘çš„éå†.assets/image-20200405205223240.png" alt="image-20200405205223240" style="zoom:80%;" />

**é€’å½’æš´åŠ›æ±‚è§£** 

æäº¤è¶…æ—¶äº†ï¼ˆä¸ºä»€ä¹ˆJavaä¸ä¼šè¶…æ—¶ï¼Ÿï¼‰

```cpp
class Solution {
public:
    int rob(TreeNode* root) {
        if(root==NULL) return 0;
        //res1 å½“ä¸‹é€‰æ‹©å·ï¼Œåˆ™å­èŠ‚ç‚¹ä¸èƒ½å·
        //res2 å½“ä¸‹ä¸å·ï¼Œå¯ä»¥å·å­èŠ‚ç‚¹
        int res1 = root->val;
        if(root->left)
        {
            res1 +=rob(root->left->left)+rob(root->left->right);
        }
        if(root->right)
        {
            res1 += rob(root->right->left)+rob(root->right->right);            
        }
        int res2 = rob(root->left)+rob(root->right);
        return max(res1,res2);  
    }
};
```

è¯¥é—®é¢˜å¯ä»¥è€ƒè™‘ä¸ºä¸€ä¸ªåŠ¨æ€è§„åˆ’é—®é¢˜ï¼Œç”±äºæš´åŠ›æ±‚è§£æœ‰å¾ˆå¤šé‡å¤æ€§è®¡ç®—ï¼Œé€šå¸¸æ˜¯ç”¨å¤‡å¿˜å½•å’ŒåŠ¨æ€è§„åˆ’çš„æ–¹æ³•æ¥è§£å†³è¯¥é—®é¢˜ã€‚

**å¤‡å¿˜å½•**

é€šè¿‡è®°å½•æ¯ä¸€æ¬¡è®¡ç®—çš„ç»“æœï¼Œå°†å…¶ä¿å­˜å†ä¸€ä¸ªå®¹å™¨ä¸­ï¼Œå½“å†æ¬¡éœ€è¦ä½¿ç”¨è¯¥ç»“æœæ—¶ç›´æ¥æå–å‡ºæ¥ã€‚é¿å…äº†å¾ˆå¤šé‡å¤è®¡ç®—ã€‚

```cpp
class Solution {
public:
    int rob(TreeNode* root) {
        if(root==NULL) return 0;
        return tryRob(root);
    }
private:
    //è®°å½•ä¸­é—´ç»“æœ
    unordered_map<TreeNode *, int> sums;
    int tryRob(TreeNode*root)
    {
        if(root==NULL) return 0;
        //å¦‚æœè®¡ç®—è¿‡è¯¥ç»“æœï¼Œç›´æ¥æå–å‡ºæ¥
        if(sum.count(root))
        {
            return sums[root];	
        }
        //å·å½“å‰èŠ‚ç‚¹
        int res1 = root->val;
        if(root->left)
        {
            res1 += tryRob(root->left->left)+tryRob(root->left->right);
        }
        if(root->right)
        {
            res1 += tryRob(root->right->left)+tryRob(root->right->right);            
        }
        //ä¸å·å½“å‰èŠ‚ç‚¹ï¼Œåˆ™å­èŠ‚ç‚¹å¯å·
        int res2 = tryRob(root->left)+tryRob(root->right);
        //è®°å½•å½“å‰æœ€ä½³å·å–æ–¹æ¡ˆç»“æœåˆ°å“ˆå¸Œè¡¨ä¸­
        sum[root] = max(res1,res2);
        return sum[root];
    }
};
```

**åŠ¨è§„åˆ’æ³•**

å½“å‰èŠ‚ç‚¹çš„å·çš„æœ€ä½³æ–¹æ¡ˆåªå’Œå…¶å­èŠ‚ç‚¹çš„æ–¹æ¡ˆæœ‰å…³ã€‚å­èŠ‚ç‚¹çš„æœ€ä½³æ–¹æ¡ˆä¸º**å­èŠ‚ç‚¹æœ¬èº«å·æˆ–ä¸å·çš„æœ€å¤§å€¼**ã€‚ç¬¦åˆåŠ¨æ€è§„åˆ’çš„æ€æƒ³ã€‚

```cpp
class Solution {
public:
    int rob(TreeNode* root) {
        if(root==NULL) return 0;
        pair<int,int> res = dp(root);
        return max(res.first,res.second);
    }
private:
   pair<int,int>dp(TreeNode*root)
   {
       if(root==NULL) return {0,0};
       //pair<rob,no_rob>
       //å­èŠ‚ç‚¹çš„å·å–æ–¹æ¡ˆï¼ŒåŒ…æ‹¬å­èŠ‚ç‚¹å·æˆ–ä¸å·çš„æƒ…å†µ
       pair<int,int> left = dp(root->left);
       pair<int,int> right = dp(root->right);
       //å½“å‰å·ï¼Œå­èŠ‚ç‚¹ä¸å·
       int rob = root->val+left.second+right.second;
       //å½“å‰ä¸å·ï¼Œå­èŠ‚ç‚¹å¯å·ï¼Œæ‰€ä»¥ç°åœ¨å·¦å³å­èŠ‚ç‚¹çš„æœ€ä½³æ–¹æ¡ˆã€‚
       int no_rob = max(left.first,left.second)+max(right.first,right.second);
       return make_pair(rob,no_rob);
   }
};
```

#### [äºŒå‰æ ‘ä¸­ç¬¬äºŒå°çš„èŠ‚ç‚¹](https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/)

<img src="äºŒå‰æ ‘çš„éå†.assets/image-20200406084149084.png" alt="image-20200406084149084" style="zoom:80%;" />

ç”±é¢˜æ„å¯çŸ¥

- æ ¹èŠ‚ç‚¹å°äºç­‰äºå­èŠ‚ç‚¹ã€‚
- å½“æ²¡æœ‰å­èŠ‚ç‚¹æˆ–è€…æ ¹èŠ‚ç‚¹å’Œå·¦å³å­èŠ‚ç‚¹ç›¸åŒï¼Œè¿”å›-1ï¼›
- å½“æ ¹èŠ‚ç‚¹ä¸å­˜åœ¨ï¼Œè¿”å›-1ï¼›



```cpp
class Solution {
public:
    int findSecondMinimumValue(TreeNode* root){
        if(root==NULL) return -1;
        if(root->left==NULL&&root->right==NULL) return -1;
        int left = root->left->val;
        int right = root->right->val;
        //å¦‚æœå½“å‰å·¦å­èŠ‚ç‚¹å’Œæ ¹èŠ‚ç‚¹ç›¸ç­‰åˆ™æœå¯»ä»¥å·¦å­èŠ‚ç‚¹ä¸ºæ ¹èŠ‚ç‚¹çš„å€’æ•°ç¬¬äºŒå°çš„ã€‚
        if(root->val==left)
        {
            left = findSecondMinimumValue(root->left);
        }
        if(root->val==right)
        {
            right = findSecondMinimumValue(root->right);
        }
        //å¦‚æœå·¦å³å­èŠ‚ç‚¹éƒ½æœ‰å­èŠ‚ç‚¹ï¼Œåˆ™å–å·¦å³æœ€å°çš„
        if(left!=-1&&right!=-1)
        {
            return min(left,right);
        }
        //å¦‚æœå·¦å­æ ‘æœ‰å€’æ•°ç¬¬äºŒå°ï¼Œå³å­æ ‘æ²¡æœ‰ï¼Œåˆ™è¿”å›å·¦å­æ ‘ç»“æœ
        if(left!=-1)
        {
            return left;
        }
        return right;
    }
};
```

#### [å°†æ»¡äºŒå‰æ ‘è½¬æ¢ä¸ºæ±‚å’Œæ ‘](https://www.nowcoder.com/practice/b31734e46ba644de85a9cf95bbd57a5f)

<img src="äºŒå‰æ ‘.assets/image-20200507205318118.png" alt="image-20200507205318118" style="zoom:80%;" />

åˆ†ææ»¡äºŒå‰æ ‘çš„ç‰¹ç‚¹ï¼Œä¸ç”¨å–æ„å»ºäºŒå‰æ ‘ã€‚

```cpp
#include <iostream>
#include <vector>
#include<algorithm>
#include<numeric>
using namespace std;
void subTree(vector<int>&inorder,int left,int right)
{
    int mid = left+(right-left)/2;
    if(left==mid)
    {
        inorder[mid] = 0;
        return;
    }
    //è¿™ä¸ªå‡½æ•°å¾ˆä¸é”™å‘¦
    //æ³¨æ„right+1ï¼Œ
    inorder[mid] = accumulate(inorder.begin()+left,inorder.begin()+right+1,-inorder[mid]);
    subTree(inorder,left,mid-1);
    subTree(inorder,mid+1,right);
}
int main()
{
    vector<int> nums;
    vector<int> preorder;
    vector<int> inorder;
    int temp;
    while (cin >> temp)
    {
        nums.push_back(temp);
    }
    int len = nums.size() / 2;
    int i = 0;
    while (i < len)
    {
        preorder.push_back(nums[i]);
        inorder.push_back(nums[i + len]);
        i++;
    }
    subTree(inorder, 0, inorder.size() - 1);
    for(auto i:inorder)
    {
        cout << i << ' ';
    }
    return 0;
}

```





### å±‚æ¬¡éå†

#### [äºŒå‰æ ‘çš„å±‚å¹³å‡å€¼](https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/)

<img src="äºŒå‰æ ‘çš„éå†.assets/image-20200406094134982.png" alt="image-20200406094134982" style="zoom:80%;" />

å°†å‰é¢å®½åº¦ä¼˜å…ˆæœç´¢ç•¥ä½œä¿®æ”¹å°±å¯ä»¥å¾—åˆ°

```cpp
class Solution {
public:
    vector<double> averageOfLevels(TreeNode* root) {
        queue<TreeNode*> q;
        vector<double> ans;
        double res = 0;
        if(root==NULL) return ans;
        q.push(root);
        while(!q.empty())
        {
            int len = q.size();
            //æ¯ä¸€å±‚è¿›è¡Œè®¡ç®—
            for(int i=0;i<len;i++)
            {
                TreeNode*temp = q.front();
                q.pop();
                res += temp->val;
                if(temp->left)
                {
                    q.push(temp->left);
                }
                if(temp->right)
                {
                    q.push(temp->right);
                }
            }
            ans.push_back(res/len);
            res= 0;
        }
        return ans;
    }
};
```

#### [æ‰¾æ ‘å·¦ä¸‹è§’çš„å€¼](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)

<img src="äºŒå‰æ ‘çš„éå†.assets/image-20200406102100133.png" alt="image-20200406102100133" style="zoom:80%;" />

å±‚æ¬¡éå†ï¼Œä¿å­˜æ¯ä¸€å±‚çš„æœ€å·¦èŠ‚ç‚¹

```cpp
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
        queue<TreeNode*> q;
        int res = 0;
        if(root==NULL) return 0;
        q.push(root);
        while(!q.empty())
        {
            int len = q.size();
            res = q.front()->val;
            //æ¯ä¸€å±‚è¿›è¡Œè®¡ç®—
            while(len--)
            {
                TreeNode*temp = q.front();
                q.pop();
                //è¿™é‡Œè¦å…ˆå¤„ç†å·¦è¾¹çš„èŠ‚ç‚¹ï¼Œæ ¹æ®queueçš„å…ˆè¿›å…ˆå‡ºï¼Œå…ˆå°†å·¦å­èŠ‚ç‚¹å‹å…¥é˜Ÿåˆ—
                if(temp->left)
                {
                    q.push(temp->left);
                }
                if(temp->right)
                {
                    q.push(temp->right);
                }
            }
        }
        return res;
    }
};
```

### äºŒå‰æœç´¢æ ‘(BST)

#### [98. éªŒè¯äºŒå‰æœç´¢æ ‘](https://leetcode-cn.com/problems/validate-binary-search-tree/)

<img src="äºŒå‰æ ‘.assets/image-20200607154529584.png" alt="image-20200607154529584" style="zoom:80%;" />

æœ‰ä¸ªè¯¯åŒºï¼ŒBSTçš„ç‰¹ç‚¹åœ¨äºå·¦å­æ ‘ä¸Š**æ‰€æœ‰çš„æ•°**éƒ½è¦å°äºæ ¹èŠ‚ç‚¹ï¼Œå³å­æ ‘ä¸Š**æ‰€æœ‰  æ ‘**éƒ½è¦å¤§äºæ ¹èŠ‚ç‚¹ã€‚è€Œä¸ä»…ä»…æ˜¯å·¦å­èŠ‚ç‚¹å°äºæ ¹èŠ‚ç‚¹ï¼Œå³å­èŠ‚ç‚¹å¤§äºæ ¹èŠ‚ç‚¹ã€‚

æ‰€ä»¥ï¼Œå·¦å­æ ‘ä¸­æ‰€æœ‰èŠ‚ç‚¹éƒ½è¦åœ¨$(-\infty,x)$ ,å³å­æ ‘æ‰€æœ‰èŠ‚ç‚¹éƒ½è¦åœ¨$(x,+\infty)$

```cpp
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        return  dfs(root,LONG_MIN,LONG_MAX);
    }
    bool dfs(TreeNode*root,long long minv,long long maxv)
    {
        if(root==NULL) return true;
        if(root->val<=minv||root->val>=maxv) return false;
        return dfs(root->left,minv,root->val)&&dfs(root->right,root->val,maxv);
    }
};
```

**ä¸­åºéå†æ³•**

```cpp
//å®šä¹‰æœ€å°å€¼
long pre = LONG_MIN;
bool isValidBST(TreeNode* root)
{
    if(root==NULL) return true;
    //é€’å½’éå†å·¦å­æ ‘
    if(!isValidBST(root->left)) return false;
    if(root->val<=pre) return fasle;
    pre = root->val;
    return isValidBST(root->right);
} 
```



#### [ä¿®å‰ªäºŒå‰æœç´¢æ ‘](https://leetcode-cn.com/problems/trim-a-binary-search-tree/)

<img src="äºŒå‰æ ‘çš„éå†.assets/image-20200406160638093.png" alt="image-20200406160638093" style="zoom:80%;" />

ç»™å®šçš„æ˜¯ä¸€ä¸ªäºŒå‰æœç´¢æ ‘ï¼Œæ³¨æ„äºŒå‰æœç´¢æ ‘çš„æ€§è´¨

- æ ¹èŠ‚ç‚¹å€¼å¤§äºæˆ–ç­‰äºå…¶å·¦å­æ ‘ä»»æ„èŠ‚ç‚¹çš„å€¼ã€‚
- æ ¹èŠ‚ç‚¹å€¼å°äºæˆ–ç­‰äºå³å­æ ‘ä»»æ„èŠ‚ç‚¹çš„å€¼
- ä»¥ä¸Šä¸¤ä¸ªæ€§è´¨åœ¨äºŒå‰æœç´¢æ ‘ä¸­çš„**æ¯ä¸€ä¸ªèŠ‚ç‚¹å‡æ»¡è¶³**

æ ¹æ®äºŒå‰æ ‘çš„æ€§è´¨å¯ä»¥è¿›è¡Œä¿®å»ºã€‚

-  å½“æ ¹èŠ‚ç‚¹çš„å€¼å¤§äºRï¼Œåˆ™å³å­æ ‘æ‰€æœ‰èŠ‚ç‚¹å€¼å‡å¤§äºRã€‚
- å½“æ ¹èŠ‚ç‚¹çš„å€¼å°äºLï¼Œåˆ™å·¦å­æ ‘æ‰€æœ‰èŠ‚ç‚¹å€¼å‡å°äºLã€‚

```cpp
class Solution {
public:
    TreeNode* trimBST(TreeNode* root, int L, int R) {
        if(root==NULL) return root;
        //å¦‚æœæ ¹èŠ‚ç‚¹å€¼å¤§äºRï¼Œå³å­æ ‘å€¼å‡å¤§äºRï¼Œä¸æ»¡è¶³æ¡ä»¶ï¼Œä¿®å‰ªæ‰
        //æ‰€ä»¥åœ¨å·¦å­æ ‘æŸ¥æ‰¾
        if(root->val>R)  
        {
            return trimBST(root->left,L,R);
        }
        //å¦‚æœæ ¹èŠ‚ç‚¹çš„å€¼å°äºLï¼Œå·¦å­æ ‘æ‰€æœ‰å€¼éƒ½å°äºLï¼Œä¸æ»¡è¶³æ¡ä»¶ï¼Œä¿®å‰ªæ‰
        //æ‰€ä»¥åœ¨å…¶å³å­æ ‘ä¸­æŸ¥æ‰¾
        if(root->val<L)
        {
            return trimBST(root->right,L,R);
        }
        root->left = trimBST(root->left,L,R);
        root->right = trimBST(root->right,L,R);
        return root;
    }
};
```

#### [äºŒå‰æœç´¢æ ‘ä¸­ç¬¬Kå°çš„å…ƒç´ ](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)

<img src="äºŒå‰æ ‘çš„éå†.assets/image-20200406171053122.png" alt="image-20200406171053122" style="zoom:80%;" />

**ä¸­åºéå†æ³•**

æ ¹æ®**äºŒå‰æœç´¢æ ‘ä¸­åºéå†ä¸ºå‡åºåºåˆ—**çš„ç‰¹ç‚¹ï¼Œå¯ä»¥åˆ©ç”¨ä¸­åºéå†çš„æ–¹æ³•æ¥å®ç°è¯¥é¢˜ï¼Œå¹¶é€šè¿‡kå€¼è¿›è¡ŒäºŒå‰æ ‘çš„ä¿®å‰ªï¼Œå½“æ»¡è¶³kåç›´æ¥è¿”å›ä¸å†è¿›è¡ŒæŸ¥æ‰¾ã€‚

**è¿­ä»£**

```cpp
class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {
        stack<TreeNode*> s;
        int cnt=0;
        int res;
        TreeNode*temp = root;
        while(temp||!s.empty())
        {
            while(temp)
            {
                s.push(temp);
                temp=temp->left;
            }
            temp = s.top();
            s.pop();
            cnt++;
            if(cnt==k)
            {
                res = temp->val;
                break;
            }
            temp = temp->right;
        }
        return res;
    }
};
```

**é€’å½’**

```cpp
class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {
        inorderTraversal(root,k);
        return res;
    }
private:
    int res;
    int count = 0;
    void inorderTraversal(TreeNode*node,int k)
    {
        if(node==NULL) return ;
        inorderTraversal(node->left,k);
        count++;
        if(k==count)
        {
            res = node->val;
        }
         inorderTraversal(node->right,k);
    }
};
```

**é€šç”¨è§£æ³•**

**æ€æƒ³å¾ˆä¸é”™ï¼Œä½†æ˜¯å¹¶ä¸é€šç”¨ï¼Œå¯¹äºäºŒå‰æœç´¢æ ‘å¯ä»¥ï¼Œå¯¹å…¶ä»–çš„äºŒå‰æ ‘ä¸ä¸€å®šï¼ŒåŸå›¾çš„æµ‹è¯•ç¤ºä¾‹å…¨æ˜¯äºŒå‰æœç´¢æ ‘ï¼Œæ‰€ä»¥èƒ½é€šè¿‡ã€‚**

å¦‚æœä¸åˆ©ç”¨äºŒå‰æœç´¢æ ‘ä¸­åºéå†ä¸ºå‡åºåºåˆ—çš„æ€§è´¨ï¼Œé‡‡ç”¨äºŒåˆ†æ³•æ¥å®ç°ã€‚

**æ­¥éª¤å¦‚ä¸‹**

æˆ‘ä»¬åªéœ€è¦å…ˆè®¡ç®—å·¦å­æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°ï¼Œè®°ä¸º `n`ï¼Œç„¶åæœ‰ä¸‰ç§æƒ…å†µã€‚

- `n` åŠ  `1` ç­‰äº `k`ï¼Œé‚£å°±è¯´æ˜å½“å‰æ ¹èŠ‚ç‚¹å°±æ˜¯æˆ‘ä»¬è¦æ‰¾çš„ã€‚

- `n`åŠ  `1` å°äº `k`ï¼Œé‚£å°±è¯´æ˜ç¬¬ `k` å°çš„æ•°ä¸€å®šåœ¨å³å­æ ‘ä¸­ï¼Œæˆ‘ä»¬åªéœ€è¦é€’å½’çš„åœ¨å³å­æ ‘ä¸­å¯»æ‰¾ç¬¬ `k - n - 1` å°çš„æ•°å³å¯ã€‚

- `n` åŠ  `1` å¤§äº `k`ï¼Œé‚£å°±è¯´æ˜ç¬¬ `k` å°ä¸ªæ•°ä¸€å®šåœ¨å·¦å­æ ‘ä¸­ï¼Œæˆ‘ä»¬åªéœ€è¦é€’å½’çš„åœ¨å·¦å­æ ‘ä¸­å¯»æ‰¾ç¬¬ `k` å°çš„æ•°å³å¯ã€‚

é‡å¤å…ƒç´ æ—¶å¥½åƒä¸å¯¹ï¼Œä¼šè‡ªåŠ¨å°†é‡å¤å…ƒç´ æ»¤æ‰ã€‚

```cpp
class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {
        int n = nodeCount(root->left);
      
        if(n+1==k)
        {
            return root->val;
        }
        else if(n+1<k)
        {
            res = kthSmallest(root->right, k - n - 1);
        }
         else if(n+1>k)
        {
            res = kthSmallest(root->left, k);
        }
        return res;
    }
private:
     int res;
    int nodeCount(TreeNode*root)
    {
        if(root==NULL) return 0;
        return nodeCount(root->left)+nodeCount(root->right)+1;
    }
};
```

#### [æŠŠäºŒå‰æœç´¢æ ‘è½¬æ¢ä¸ºç´¯åŠ æ ‘](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)

<img src="äºŒå‰æ ‘çš„éå†.assets/image-20200406212835808.png" alt="image-20200406212835808" style="zoom:80%;" />

æ ¹æ®äºŒå‰æœç´¢æ ‘çš„ç‰¹æ€§ï¼Œä»å³å­æ ‘å¼€å§‹éå†ï¼Œé€æ¸å¯¹èŠ‚ç‚¹è¿›è¡Œç´¯åŠ ï¼Œåœ¨éå†å·¦å­æ ‘ï¼Œè¿›è¡Œç´¯åŠ ã€‚

åŸºäºä¸­åºéå†ï¼Œå…ˆä¾¿åˆ©å·¦å­æ ‘ï¼Œå¤„ç†ï¼Œå†éå†å³å­æ ‘ã€‚æœ¬é¢˜å…ˆéå†å³å­æ ‘ï¼Œç´¯åŠ  æ›¿æ¢ï¼Œå†éå†å·¦å­æ ‘ã€‚æ‰€ä»¥æœ¬é¢˜åªéœ€è¦å¯¹ä¸­åºéå†ç•¥ä½œä¿®æ”¹å³å¯ã€‚

æ•´ä½“æ¥è®²ï¼Œæ ¹èŠ‚ç‚¹ï¼ˆrootï¼‰ç´¯åŠ åï¼Œå°†æ‰€æœ‰å³å­æ ‘èŠ‚ç‚¹å€¼çš„å’ŒåŠ åˆ°root->valï¼Œæ¯•ç«Ÿå³å­æ ‘æ‰€æœ‰å€¼éƒ½æ¯”æ ¹èŠ‚ç‚¹å¤§ã€‚

**é€’å½’æ³•**

```cpp
class Solution {
public:
    int num=0;
    TreeNode* convertBST(TreeNode* root) {
        if(root)
        {
            //éå†å³å­æ ‘
            convertBST(root->right);
            //å›æº¯ç´¯åŠ (ä»åº•éƒ¨å‘ä¸Šç´¯åŠ )
            root->val+=num;
            num=root->val;
            //éå†å·¦å­æ ‘,ä»ä¸Šå¾€ä¸‹ç´¯åŠ 
            convertBST(root->left); 
            return root;
        }
        return NULL;
    }
};
```

**è¿­ä»£æ³•**

```cpp
class Solution{
public:
    TreeNode*convertBST(TreeNode*root)
    {
        if(root==NULL) return root;
        int sum=0;
        stack<TreeNode*>s;
        TreeNode*cur = root;
        while(cur||!s.empty())
        {
            //éå†å³å­æ ‘ï¼Œåˆ°å¶å­èŠ‚ç‚¹
            while(cur)
            {
                s.push(cur);
                cur=cur->right;
            }
            cur = s.top();
            s.pop();
            //ç´¯åŠ 
            sum += cur->val;
            cur->val = sum;
            cur = cur->left;
        }
        return root;
    }
};
```

#### [ äºŒå‰æœç´¢æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)

<img src="äºŒå‰æ ‘çš„éå†.assets/image-20200407091014825.png" alt="image-20200407091014825" style="zoom:80%;" />

å¯¹äºæœç´¢äºŒå‰æ ‘ï¼Œå¦‚æœpã€qèŠ‚ç‚¹çš„å€¼éƒ½å¤§äºæˆ–å°äºæ ¹èŠ‚ç‚¹ï¼Œåˆ™äºŒè€…åœ¨åŒä¸€å­æ ‘ä¸Šã€‚å¦åˆ™ï¼ŒäºŒè€…å±äºä¸åŒå­æ ‘ï¼Œæ ¹èŠ‚ç‚¹å³ä¸ºæœ€è¿‘å…¬å…±ç¥–å…ˆ

```cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root==NULL) return root;
        if(root->val>p->val&&root->val>q->val)
        {
            return lowestCommonAncestor(root->left,p,q);
        }
        if(root->val<p->val&&root->val<q->val)
        {
            return lowestCommonAncestor(root->right,p,q);
        }
        return root;
        
    }
};
```

**è¿­ä»£æ³•**

```cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root==NULL) return root;
        while(root)
        {
            if(root->val>p->val&&root->val>q->val)
            {
                root = root->left;
            }
            else if(root->val<p->val&&root->val<q->val)
            {
                root = root->right;
            }
            else
            {
                return root;
            }
        }
        return NULL;
    }
};
```

#### [äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

<img src="äºŒå‰æ ‘çš„éå†.assets/image-20200407093712331.png" alt="image-20200407093712331" style="zoom:80%;" />

äºŒå‰æ ‘å…¬å…±ç¥–å…ˆçš„é€šç”¨è§£æ³•ï¼Œä¸ä¾èµ–äºäºŒå‰æ ‘çš„ç‰¹æ€§

- åœ¨å·¦å³å­æ ‘å¯»æ‰¾ç›®æ ‡èŠ‚ç‚¹ï¼ˆpæˆ–è€…qï¼‰ï¼Œå¦‚æœæœ‰è¿”å›è¯¥èŠ‚ç‚¹ã€‚
- å¦‚æœåœ¨å·¦å³å­æ ‘ä¸­å‡æ‰¾åˆ°äº†ç›®æ ‡èŠ‚ç‚¹ï¼Œåˆ™æ ¹èŠ‚ç‚¹å³æœ€è¿‘å…¬å…±ç¥–å…ˆã€‚å¦åˆ™å°±åœ¨å…¶ä¸­ä¸€ä¸ªå­æ ‘ä¸Šã€‚é€’å½’å¯»æ‰¾å°±å¾—äº†ã€‚

```cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (!root || root == p || root == q) {
            return root;
        }
        TreeNode *left = lowestCommonAncestor(root->left, p, q);
        TreeNode *right = lowestCommonAncestor(root->right, p, q);
        if (left && right) return root;   //åœ¨å·¦å³ä¸¤ä¾§
        return left ? left : right;
    }
};
```



#### [å°†æœ‰åºæ•°ç»„è½¬æ¢ä¸ºäºŒå‰æœç´¢æ ‘](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)

<img src="äºŒå‰æ ‘çš„éå†.assets/image-20200407111340062.png" alt="image-20200407111340062" style="zoom:80%;" />

æ ¹æ®ä¸­åºéå†è¿˜åŸä¸€é¢—æ ‘ï¼Œåˆæƒ³åˆ°äº† 105 é¢˜ å’Œ 106 é¢˜ï¼Œé€šè¿‡ä¸­åºéå†åŠ å‰åºéå†æˆ–è€…ä¸­åºéå†åŠ ååºéå†æ¥è¿˜åŸä¸€æ£µæ ‘ã€‚å‰åºï¼ˆååºï¼‰éå†çš„ä½œç”¨å‘¢ï¼Ÿæä¾›æ ¹èŠ‚ç‚¹ï¼ç„¶åæ ¹æ®æ ¹èŠ‚ç‚¹ï¼Œå°±å¯ä»¥é€’å½’çš„ç”Ÿæˆå·¦å³å­æ ‘ã€‚

è¿™é‡Œçš„è¯æ€ä¹ˆçŸ¥é“æ ¹èŠ‚ç‚¹å‘¢ï¼Ÿå¹³è¡¡äºŒå‰æ ‘ï¼Œæ—¢ç„¶è¦åšåˆ°å¹³è¡¡ï¼Œæˆ‘ä»¬åªè¦æŠŠæ ¹èŠ‚ç‚¹é€‰ä¸ºæ•°ç»„çš„ä¸­ç‚¹å³å¯ã€‚

ç»¼ä¸Šï¼Œå’Œä¹‹å‰ä¸€æ ·ï¼Œæ‰¾åˆ°äº†æ ¹èŠ‚ç‚¹ï¼Œç„¶åæŠŠæ•°ç»„ä¸€åˆ†ä¸ºäºŒï¼Œè¿›å…¥é€’å½’å³å¯ã€‚æ³¨æ„è¿™é‡Œçš„è¾¹ç•Œæƒ…å†µï¼ŒåŒ…æ‹¬å·¦è¾¹ç•Œï¼Œä¸åŒ…æ‹¬å³è¾¹ç•Œã€‚

```cpp
class Solution {
public:
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        if(nums.size()==0) return NULL;
        return helper(nums,0,nums.size());
        
    }
private:
    TreeNode* helper(vector<int>&nums,int start,int end)
    {
        if(start==end) return NULL;
        int mid = (start+end)>>1;
        TreeNode*root = new TreeNode(nums[mid]);
        //æ³¨æ„è¾¹ç•Œæ¡ä»¶ï¼Œå³è¾¹ç•Œæ˜¯å–ä¸åˆ°çš„ã€‚
        root->left = helper(nums,start,mid);
        root->right = helper(nums,mid+1,end);
        return root;
    }
};
```

#### [æœ‰åºé“¾è¡¨è½¬æ¢äºŒå‰æœç´¢æ ‘](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/)

å’Œå‰ä¸€é¢˜æ€æƒ³ä¸€æ ·ï¼Œä¸åŒä¹‹å¤„ä»…ä»…æ˜¯å°†å¯¹æ•°ç»„çš„åˆ†å‰²æ¢æˆäº†å¯¹é“¾è¡¨çš„åˆ†å‰²ã€‚åŒæ ·æ³¨æ„è¾¹ç•Œæ¡ä»¶

```cpp
class Solution {
public:
    TreeNode* sortedListToBST(ListNode* head) {
        if(head==NULL) return NULL;
        if(head->next==NULL) return new TreeNode(head->val);
        ListNode*premid=findPreMid(head);
        ListNode*right = premid->next->next;
        TreeNode*root = new TreeNode(premid->next->val);
        //æ–­å¼€é“¾è¡¨ï¼Œåˆ†å‰²
        //1->2->3>4>5
        //1->2->NULL|3|4->5->NULL
        premid->next = NULL;
        root->left = sortedListToBST(head);
        root->right = sortedListToBST(right);
        return root;
    
    }
private:
    //æ‰¾é“¾è¡¨ä¸­ç‚¹çš„å‰ä¸€èŠ‚ç‚¹ï¼Œä¾¿äºåé¢å¯¹é“¾è¡¨çš„åˆ†å‰²ã€‚
    ListNode*findPreMid(ListNode* head)
    {
        ListNode *slow=head, *fast=head;
        ListNode *pre;
        while (fast && fast->next) {
            pre = slow;
            slow = slow->next;
            fast = fast->next->next;
        }
        return pre;
    }
};
```

#### [ä¸¤æ•°ä¹‹å’Œ IV - è¾“å…¥ BST](https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/)

<img src="äºŒå‰æ ‘.assets/image-20200407151453565.png" alt="image-20200407151453565" style="zoom:80%;" />

å…ˆè¿›è¡Œä¸­åºéå†ï¼Œå¾—åˆ°æœ‰åºæ•°ç»„ï¼Œå†ç”¨åŒæŒ‡é’ˆçš„æ–¹æ³•è¿›è¡ŒæŸ¥æ‰¾ã€‚

```cpp
class Solution {
public:
    bool findTarget(TreeNode* root, int k) {
        if(root==NULL) return false;
        inorderTraversal(root);
        int left = 0;
        int right = nums.size()-1;
        while(left<right)
        {
            int sum = nums[left]+nums[right];
            if(sum==k)
            {
                return true;
            }
            
            if(sum>k)
            {
                right--;
            }
            if(sum<k)
            {
                left++;
            }
        }
        return false;
    }
private:
    vector<int> nums;
    //ä¸­åºéå†
    void inorderTraversal(TreeNode*root)
    {
        if(root==NULL) return;
        inorderTraversal(root->left);
        nums.push_back(root->val);
        inorderTraversal(root->right);
    }
    
};
```

#### [äºŒå‰æœç´¢æ ‘çš„æœ€å°ç»å¯¹å·®](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/)

<img src="äºŒå‰æ ‘.assets/image-20200407154351656.png" alt="image-20200407154351656" style="zoom:80%;" />

ä¸­åºéå†çš„åŒæ—¶è¿›è¡Œå·®å€¼è®¡ç®—ã€‚

```cpp
class Solution {
public:
    int getMinimumDifference(TreeNode* root) {
        inorderTraversal(root);
        return res;
    }
private:
    TreeNode* pre = NULL;
    int res = INT_MAX;
    void inorderTraversal(TreeNode*root)
    {
        if(root==NULL) return;
        inorderTraversal(root->left);
        if(pre!=NULL)
        {
            res = min(res,root->val-pre->val);
        }
        pre = root;
        inorderTraversal(root->right);
    }
};
```

#### [äºŒå‰æœç´¢æ ‘ä¸­çš„ä¼—æ•°](https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/)

<img src="äºŒå‰æ ‘.assets/image-20200407165526635.png" alt="image-20200407165526635" style="zoom:80%;" />

æ€è·¯ï¼šäºŒå‰æœç´¢æ ‘çš„ä¸­åºéå†æ˜¯ä¸€ä¸ªå‡åºåºåˆ—ï¼Œé€ä¸ªæ¯”å¯¹å½“å‰ç»“ç‚¹(root)å€¼ä¸å‰é©±ç»“ç‚¹ï¼ˆpre)å€¼ã€‚æ›´æ–°å½“å‰èŠ‚ç‚¹å€¼å‡ºç°æ¬¡æ•°(curTimes)åŠæœ€å¤§å‡ºç°æ¬¡æ•°(maxTimes)ï¼Œæ›´æ–°è§„åˆ™ï¼š

- è‹¥curTimes=maxTimes,å°†root->valæ·»åŠ åˆ°ç»“æœå‘é‡(res)ä¸­ï¼›
- è‹¥curTimes>maxTimes,æ¸…ç©ºres,å°†root->valæ·»åŠ åˆ°res,å¹¶æ›´æ–°maxTimesä¸ºcurTimesã€‚

```cpp
class Solution {
public:
    vector<int> findMode(TreeNode* root) {
        vector<int>res;
        if(root==NULL) return res;
        
        int curCnt = 1;
        int maxCnt = 0;
        helper(root,curCnt,maxCnt,res);
        return res;    
    }
private:
    TreeNode*pre = NULL;
    void helper(TreeNode*root,int& curCnt,int& maxCnt,vector<int>&res)
    {
        if(root==NULL) return;
        helper(root->left,curCnt,maxCnt,res);
        if(pre)
        {
            if(root->val==pre->val)
            { 
                curCnt++;
            }
            else
            {
                curCnt = 1;
            }
        }
        if(curCnt==maxCnt)
        {
            res.push_back(root->val);
        }
        else if(curCnt>maxCnt)
        {
            res.clear();
            res.push_back(root->val);
            maxCnt = curCnt;
        }
        pre=root;
        helper(root->right,curCnt,maxCnt,res);
    }
};
```

éšå¼è°ƒç”¨ preèŠ‚ç‚¹ï¼Œ`TreeNode* &pre;`ç›¸å½“äºå®šä¹‰å…¨å±€TreeNode*pre

```cpp
class Solution {
public:
    vector<int> findMode(TreeNode* root) {
        vector<int>res;
        if(root==NULL) return res;
        TreeNode*pre = NULL;
        int curCnt = 1;
        int maxCnt = 0;
        helper(root,pre,curCnt,maxCnt,res);
        return res;    
    }
private:
    void helper(TreeNode*root,TreeNode*&pre,int& curCnt,int& maxCnt,vector<int>&res)
    {
        if(root==NULL) return;
        helper(root->left,pre,curCnt,maxCnt,res);
        if(pre)
        {
            if(root->val==pre->val)
            {
                curCnt++;
            }
            else
            {
                curCnt = 1;
            }
        }
        if(curCnt==maxCnt)
        {
            res.push_back(root->val);
        }
        else if(curCnt>maxCnt)
        {
            res.clear();
            res.push_back(root->val);
            maxCnt = curCnt;
        }
        pre=root;
        helper(root->right,pre,curCnt,maxCnt,res);
    }
};
```

#### åˆ¤æ–­åºåˆ—æ˜¯ä¸äºŒå‰æœç´¢æ ‘çš„ååºéå†

æ ¹æ®äºŒå‰æœç´¢æ ‘çš„ç‰¹ç‚¹ï¼Œå…¶åç»­éå†çš„æœ€åä¸€ä¸ªæ•°ä¸ºæ ¹èŠ‚ç‚¹ã€‚æ‰€ä»¥å¯ä»¥æ ¹æ®äºŒå‰æœç´¢æ ‘çš„æ€§è´¨æ‰¾åˆ°äºŒå‰æœç´¢æ ‘çš„å·¦å³å­æ ‘ã€‚é€’å½’çš„å¯¹å·¦å³å­æ ‘è¿›è¡Œåˆ¤æ–­ã€‚

ä¾‹å¦‚

1ï¼Œ5ï¼Œ3ï¼Œ9ï¼Œ12ï¼Œ10ï¼Œ7

æ ¹èŠ‚ç‚¹ä¸º7ï¼Œå·¦å­æ ‘ä¸º1ï¼Œ5ï¼Œ3ï¼Œå³å­æ ‘ä¸º9ï¼Œ12ï¼Œ10ï¼Œ

```cpp
struct TreeNode{
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x):val(x),left(NULL),right(NULL){}
};
class Solution{
    public:
    bool VerifySquenceOfBST(vector<int> sequenece)
    {
        if(sequence.size()==0) return fasle;
        return help(sequence,0,sequence.size()-1);
    }
    private:
    bool help(vector<int> sequence,int start, int end)
    {
        if(end>=start) return true;
        int i = start;
        for(;i<end;i++)
        {
            if(sequence[i]>sequence[end]) break;
        }
        for(int j = i;j<end;j++)
        {
            if(sequence[j]<sequence[end]) return fasle;
        }
        return help(sequence,start,i-1)&&help(sequence,i,end-1);
    }
};
```



#### æ„å»ºäºŒå‰æ ‘

##### ç»™å‡º**æœç´¢äºŒå‰æ ‘**çš„åç»­éå†æ•°ç»„ï¼Œæ„å»ºäºŒå‰æ ‘

åç»­éå†çš„æœ€åä¸€ä¸ªæ•°ä¸ºæ ¹èŠ‚ç‚¹ã€‚

```cpp
class Solution
{
    //ç»™å‡ºæœç´¢äºŒå‰æ ‘çš„åç»­éå†ï¼Œæ„å»ºäºŒå‰æ ‘
public:
    TreeNode *build(vector<int> &backOrder)
    {
        if (backOrder.size() == 0)
        {
            return NULL;
        }
        return buildTree(backOrder, 0, backOrder.size() - 1);
    }

private:
    TreeNode *buildTree(vector<int> &backOrded, int left, int right)
    {
        if (left > right)
        {
            return NULL;
        }
        TreeNode*root = new TreeNode(backOrded[right]);
        if (left == right)
        {
            return root;
        }
        int mid=0;
        for (int i = left; i < right; i++)
        {
            if (backOrded[i] < backOrded[right])
            {
                mid = i;
            }
        }
        root->left = buildTree(backOrded, left, mid);
        root->right = buildTree(backOrded, mid + 1, right-1);   // æœ€åä¸€ä¸ªæ•°å·²ç»æ‹¿èµ°äº†
        return root;
    }
};
```

##### [ç»™å‡ºå‰åºéå†å’Œåç»­éå†ï¼Œæ„å»ºäºŒå‰æ ‘](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

`preorder:[3, 9, 20, 15, 7]`

`inorder:[9, 3, 15, 20, 7]`

å…³é”®åœ¨äºåˆ’åˆ†å·¦å³å­æ ‘ï¼Œ

äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ä¸ºå‰åºéå†ä¸­çš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œé€šè¿‡ä¸­åºéå†å°±å¯ä»¥çŸ¥é“å·¦å³å­æ ‘åˆ†åˆ«æœ‰å¤šå°‘èŠ‚ç‚¹

```cpp
struct TreeNode{
    int val;
    TreeNode*left;
    TreeNode*right;
    TreeNode(int x):val(x),left(NULL),right(NULL){}
};
class Solution {
    unordered_map<int,int> hmap;
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        int n = inorder.size();
        for(int i=0;i<n;i++)
        {
            hmap[inorder[i]]=i;
        }
        return dfs(preorder,inorder,0,n-1,0,n-1);
        
    }
    TreeNode*dfs(vector<int>& preorder,vector<int>& inorder,int pl,int pr,int il,int ir)
    {
        if(pl>pr) return NULL;
        int k = hmap[preorder[pl]];
        int len = k-il;
        auto root = new TreeNode(preorder[pl]);
        root->left = dfs(preorder,inorder,pl+1,pl+len,il,k-1);
        root->right = dfs(preorder,inorder,pl+len+1,pr,il+len+1,ir);
        return root;
    }
};
```



